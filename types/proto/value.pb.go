// Code generated by protoc-gen-go. DO NOT EDIT.
// source: value.proto

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	value.proto

It has these top-level messages:
	Value
	Atom
	Keyword
	String
	Num
	Boolean
	List
	Vector
	PrimFn
	KVPair
	Dict
	Ref
	Lambda
	LambdaRec
	SVPair
	Env
	IVPair
	Intmap
	State
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto1.ProtoPackageIsVersion2 // please upgrade the proto package

type Value struct {
	// Types that are valid to be assigned to Value:
	//	*Value_Atom
	//	*Value_Keyword
	//	*Value_String_
	//	*Value_Num
	//	*Value_Boolean
	//	*Value_List
	//	*Value_Vector
	//	*Value_PrimFn
	//	*Value_Dict
	//	*Value_Ref
	//	*Value_Lambda
	//	*Value_LambdaRec
	//	*Value_Env
	//	*Value_State
	Value isValue_Value `protobuf_oneof:"value"`
}

func (m *Value) Reset()                    { *m = Value{} }
func (m *Value) String() string            { return proto1.CompactTextString(m) }
func (*Value) ProtoMessage()               {}
func (*Value) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isValue_Value interface {
	isValue_Value()
}

type Value_Atom struct {
	Atom *Atom `protobuf:"bytes,1,opt,name=atom,oneof"`
}
type Value_Keyword struct {
	Keyword *Keyword `protobuf:"bytes,2,opt,name=keyword,oneof"`
}
type Value_String_ struct {
	String_ *String `protobuf:"bytes,3,opt,name=string,oneof"`
}
type Value_Num struct {
	Num *Num `protobuf:"bytes,4,opt,name=num,oneof"`
}
type Value_Boolean struct {
	Boolean *Boolean `protobuf:"bytes,5,opt,name=boolean,oneof"`
}
type Value_List struct {
	List *List `protobuf:"bytes,6,opt,name=list,oneof"`
}
type Value_Vector struct {
	Vector *Vector `protobuf:"bytes,7,opt,name=vector,oneof"`
}
type Value_PrimFn struct {
	PrimFn *PrimFn `protobuf:"bytes,8,opt,name=primFn,oneof"`
}
type Value_Dict struct {
	Dict *Dict `protobuf:"bytes,9,opt,name=dict,oneof"`
}
type Value_Ref struct {
	Ref *Ref `protobuf:"bytes,10,opt,name=ref,oneof"`
}
type Value_Lambda struct {
	Lambda *Lambda `protobuf:"bytes,11,opt,name=lambda,oneof"`
}
type Value_LambdaRec struct {
	LambdaRec *LambdaRec `protobuf:"bytes,12,opt,name=lambdaRec,oneof"`
}
type Value_Env struct {
	Env *Env `protobuf:"bytes,13,opt,name=env,oneof"`
}
type Value_State struct {
	State *State `protobuf:"bytes,14,opt,name=state,oneof"`
}

func (*Value_Atom) isValue_Value()      {}
func (*Value_Keyword) isValue_Value()   {}
func (*Value_String_) isValue_Value()   {}
func (*Value_Num) isValue_Value()       {}
func (*Value_Boolean) isValue_Value()   {}
func (*Value_List) isValue_Value()      {}
func (*Value_Vector) isValue_Value()    {}
func (*Value_PrimFn) isValue_Value()    {}
func (*Value_Dict) isValue_Value()      {}
func (*Value_Ref) isValue_Value()       {}
func (*Value_Lambda) isValue_Value()    {}
func (*Value_LambdaRec) isValue_Value() {}
func (*Value_Env) isValue_Value()       {}
func (*Value_State) isValue_Value()     {}

func (m *Value) GetValue() isValue_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Value) GetAtom() *Atom {
	if x, ok := m.GetValue().(*Value_Atom); ok {
		return x.Atom
	}
	return nil
}

func (m *Value) GetKeyword() *Keyword {
	if x, ok := m.GetValue().(*Value_Keyword); ok {
		return x.Keyword
	}
	return nil
}

func (m *Value) GetString_() *String {
	if x, ok := m.GetValue().(*Value_String_); ok {
		return x.String_
	}
	return nil
}

func (m *Value) GetNum() *Num {
	if x, ok := m.GetValue().(*Value_Num); ok {
		return x.Num
	}
	return nil
}

func (m *Value) GetBoolean() *Boolean {
	if x, ok := m.GetValue().(*Value_Boolean); ok {
		return x.Boolean
	}
	return nil
}

func (m *Value) GetList() *List {
	if x, ok := m.GetValue().(*Value_List); ok {
		return x.List
	}
	return nil
}

func (m *Value) GetVector() *Vector {
	if x, ok := m.GetValue().(*Value_Vector); ok {
		return x.Vector
	}
	return nil
}

func (m *Value) GetPrimFn() *PrimFn {
	if x, ok := m.GetValue().(*Value_PrimFn); ok {
		return x.PrimFn
	}
	return nil
}

func (m *Value) GetDict() *Dict {
	if x, ok := m.GetValue().(*Value_Dict); ok {
		return x.Dict
	}
	return nil
}

func (m *Value) GetRef() *Ref {
	if x, ok := m.GetValue().(*Value_Ref); ok {
		return x.Ref
	}
	return nil
}

func (m *Value) GetLambda() *Lambda {
	if x, ok := m.GetValue().(*Value_Lambda); ok {
		return x.Lambda
	}
	return nil
}

func (m *Value) GetLambdaRec() *LambdaRec {
	if x, ok := m.GetValue().(*Value_LambdaRec); ok {
		return x.LambdaRec
	}
	return nil
}

func (m *Value) GetEnv() *Env {
	if x, ok := m.GetValue().(*Value_Env); ok {
		return x.Env
	}
	return nil
}

func (m *Value) GetState() *State {
	if x, ok := m.GetValue().(*Value_State); ok {
		return x.State
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Value) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), func(msg proto1.Message) (n int), []interface{}) {
	return _Value_OneofMarshaler, _Value_OneofUnmarshaler, _Value_OneofSizer, []interface{}{
		(*Value_Atom)(nil),
		(*Value_Keyword)(nil),
		(*Value_String_)(nil),
		(*Value_Num)(nil),
		(*Value_Boolean)(nil),
		(*Value_List)(nil),
		(*Value_Vector)(nil),
		(*Value_PrimFn)(nil),
		(*Value_Dict)(nil),
		(*Value_Ref)(nil),
		(*Value_Lambda)(nil),
		(*Value_LambdaRec)(nil),
		(*Value_Env)(nil),
		(*Value_State)(nil),
	}
}

func _Value_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*Value)
	// value
	switch x := m.Value.(type) {
	case *Value_Atom:
		b.EncodeVarint(1<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Atom); err != nil {
			return err
		}
	case *Value_Keyword:
		b.EncodeVarint(2<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Keyword); err != nil {
			return err
		}
	case *Value_String_:
		b.EncodeVarint(3<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.String_); err != nil {
			return err
		}
	case *Value_Num:
		b.EncodeVarint(4<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Num); err != nil {
			return err
		}
	case *Value_Boolean:
		b.EncodeVarint(5<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Boolean); err != nil {
			return err
		}
	case *Value_List:
		b.EncodeVarint(6<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.List); err != nil {
			return err
		}
	case *Value_Vector:
		b.EncodeVarint(7<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Vector); err != nil {
			return err
		}
	case *Value_PrimFn:
		b.EncodeVarint(8<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.PrimFn); err != nil {
			return err
		}
	case *Value_Dict:
		b.EncodeVarint(9<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Dict); err != nil {
			return err
		}
	case *Value_Ref:
		b.EncodeVarint(10<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Ref); err != nil {
			return err
		}
	case *Value_Lambda:
		b.EncodeVarint(11<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Lambda); err != nil {
			return err
		}
	case *Value_LambdaRec:
		b.EncodeVarint(12<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.LambdaRec); err != nil {
			return err
		}
	case *Value_Env:
		b.EncodeVarint(13<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Env); err != nil {
			return err
		}
	case *Value_State:
		b.EncodeVarint(14<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.State); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Value.Value has unexpected type %T", x)
	}
	return nil
}

func _Value_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*Value)
	switch tag {
	case 1: // value.atom
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(Atom)
		err := b.DecodeMessage(msg)
		m.Value = &Value_Atom{msg}
		return true, err
	case 2: // value.keyword
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(Keyword)
		err := b.DecodeMessage(msg)
		m.Value = &Value_Keyword{msg}
		return true, err
	case 3: // value.string
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(String)
		err := b.DecodeMessage(msg)
		m.Value = &Value_String_{msg}
		return true, err
	case 4: // value.num
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(Num)
		err := b.DecodeMessage(msg)
		m.Value = &Value_Num{msg}
		return true, err
	case 5: // value.boolean
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(Boolean)
		err := b.DecodeMessage(msg)
		m.Value = &Value_Boolean{msg}
		return true, err
	case 6: // value.list
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(List)
		err := b.DecodeMessage(msg)
		m.Value = &Value_List{msg}
		return true, err
	case 7: // value.vector
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(Vector)
		err := b.DecodeMessage(msg)
		m.Value = &Value_Vector{msg}
		return true, err
	case 8: // value.primFn
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(PrimFn)
		err := b.DecodeMessage(msg)
		m.Value = &Value_PrimFn{msg}
		return true, err
	case 9: // value.dict
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(Dict)
		err := b.DecodeMessage(msg)
		m.Value = &Value_Dict{msg}
		return true, err
	case 10: // value.ref
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(Ref)
		err := b.DecodeMessage(msg)
		m.Value = &Value_Ref{msg}
		return true, err
	case 11: // value.lambda
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(Lambda)
		err := b.DecodeMessage(msg)
		m.Value = &Value_Lambda{msg}
		return true, err
	case 12: // value.lambdaRec
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(LambdaRec)
		err := b.DecodeMessage(msg)
		m.Value = &Value_LambdaRec{msg}
		return true, err
	case 13: // value.env
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(Env)
		err := b.DecodeMessage(msg)
		m.Value = &Value_Env{msg}
		return true, err
	case 14: // value.state
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(State)
		err := b.DecodeMessage(msg)
		m.Value = &Value_State{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Value_OneofSizer(msg proto1.Message) (n int) {
	m := msg.(*Value)
	// value
	switch x := m.Value.(type) {
	case *Value_Atom:
		s := proto1.Size(x.Atom)
		n += proto1.SizeVarint(1<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Value_Keyword:
		s := proto1.Size(x.Keyword)
		n += proto1.SizeVarint(2<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Value_String_:
		s := proto1.Size(x.String_)
		n += proto1.SizeVarint(3<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Value_Num:
		s := proto1.Size(x.Num)
		n += proto1.SizeVarint(4<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Value_Boolean:
		s := proto1.Size(x.Boolean)
		n += proto1.SizeVarint(5<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Value_List:
		s := proto1.Size(x.List)
		n += proto1.SizeVarint(6<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Value_Vector:
		s := proto1.Size(x.Vector)
		n += proto1.SizeVarint(7<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Value_PrimFn:
		s := proto1.Size(x.PrimFn)
		n += proto1.SizeVarint(8<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Value_Dict:
		s := proto1.Size(x.Dict)
		n += proto1.SizeVarint(9<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Value_Ref:
		s := proto1.Size(x.Ref)
		n += proto1.SizeVarint(10<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Value_Lambda:
		s := proto1.Size(x.Lambda)
		n += proto1.SizeVarint(11<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Value_LambdaRec:
		s := proto1.Size(x.LambdaRec)
		n += proto1.SizeVarint(12<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Value_Env:
		s := proto1.Size(x.Env)
		n += proto1.SizeVarint(13<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Value_State:
		s := proto1.Size(x.State)
		n += proto1.SizeVarint(14<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Atom struct {
	Atom string `protobuf:"bytes,1,opt,name=atom" json:"atom,omitempty"`
}

func (m *Atom) Reset()                    { *m = Atom{} }
func (m *Atom) String() string            { return proto1.CompactTextString(m) }
func (*Atom) ProtoMessage()               {}
func (*Atom) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Atom) GetAtom() string {
	if m != nil {
		return m.Atom
	}
	return ""
}

type Keyword struct {
	Keyword string `protobuf:"bytes,1,opt,name=keyword" json:"keyword,omitempty"`
}

func (m *Keyword) Reset()                    { *m = Keyword{} }
func (m *Keyword) String() string            { return proto1.CompactTextString(m) }
func (*Keyword) ProtoMessage()               {}
func (*Keyword) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Keyword) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

type String struct {
	String_ string `protobuf:"bytes,1,opt,name=string" json:"string,omitempty"`
}

func (m *String) Reset()                    { *m = String{} }
func (m *String) String() string            { return proto1.CompactTextString(m) }
func (*String) ProtoMessage()               {}
func (*String) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *String) GetString_() string {
	if m != nil {
		return m.String_
	}
	return ""
}

type Num struct {
	Num int64 `protobuf:"varint,1,opt,name=num" json:"num,omitempty"`
}

func (m *Num) Reset()                    { *m = Num{} }
func (m *Num) String() string            { return proto1.CompactTextString(m) }
func (*Num) ProtoMessage()               {}
func (*Num) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Num) GetNum() int64 {
	if m != nil {
		return m.Num
	}
	return 0
}

type Boolean struct {
	Boolean bool `protobuf:"varint,1,opt,name=boolean" json:"boolean,omitempty"`
}

func (m *Boolean) Reset()                    { *m = Boolean{} }
func (m *Boolean) String() string            { return proto1.CompactTextString(m) }
func (*Boolean) ProtoMessage()               {}
func (*Boolean) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Boolean) GetBoolean() bool {
	if m != nil {
		return m.Boolean
	}
	return false
}

type List struct {
	Values []*Value `protobuf:"bytes,1,rep,name=values" json:"values,omitempty"`
}

func (m *List) Reset()                    { *m = List{} }
func (m *List) String() string            { return proto1.CompactTextString(m) }
func (*List) ProtoMessage()               {}
func (*List) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *List) GetValues() []*Value {
	if m != nil {
		return m.Values
	}
	return nil
}

type Vector struct {
	Values []*Value `protobuf:"bytes,1,rep,name=values" json:"values,omitempty"`
}

func (m *Vector) Reset()                    { *m = Vector{} }
func (m *Vector) String() string            { return proto1.CompactTextString(m) }
func (*Vector) ProtoMessage()               {}
func (*Vector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Vector) GetValues() []*Value {
	if m != nil {
		return m.Values
	}
	return nil
}

type PrimFn struct {
	Fn string `protobuf:"bytes,1,opt,name=fn" json:"fn,omitempty"`
}

func (m *PrimFn) Reset()                    { *m = PrimFn{} }
func (m *PrimFn) String() string            { return proto1.CompactTextString(m) }
func (*PrimFn) ProtoMessage()               {}
func (*PrimFn) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *PrimFn) GetFn() string {
	if m != nil {
		return m.Fn
	}
	return ""
}

type KVPair struct {
	Key   *Value `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value *Value `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *KVPair) Reset()                    { *m = KVPair{} }
func (m *KVPair) String() string            { return proto1.CompactTextString(m) }
func (*KVPair) ProtoMessage()               {}
func (*KVPair) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *KVPair) GetKey() *Value {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *KVPair) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

type Dict struct {
	Pairs []*KVPair `protobuf:"bytes,1,rep,name=pairs" json:"pairs,omitempty"`
}

func (m *Dict) Reset()                    { *m = Dict{} }
func (m *Dict) String() string            { return proto1.CompactTextString(m) }
func (*Dict) ProtoMessage()               {}
func (*Dict) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *Dict) GetPairs() []*KVPair {
	if m != nil {
		return m.Pairs
	}
	return nil
}

type Ref struct {
	Ref uint64 `protobuf:"varint,1,opt,name=ref" json:"ref,omitempty"`
}

func (m *Ref) Reset()                    { *m = Ref{} }
func (m *Ref) String() string            { return proto1.CompactTextString(m) }
func (*Ref) ProtoMessage()               {}
func (*Ref) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Ref) GetRef() uint64 {
	if m != nil {
		return m.Ref
	}
	return 0
}

type Lambda struct {
	Args   []string `protobuf:"bytes,1,rep,name=args" json:"args,omitempty"`
	Bodies []*Value `protobuf:"bytes,2,rep,name=bodies" json:"bodies,omitempty"`
	Env    *Env     `protobuf:"bytes,3,opt,name=env" json:"env,omitempty"`
}

func (m *Lambda) Reset()                    { *m = Lambda{} }
func (m *Lambda) String() string            { return proto1.CompactTextString(m) }
func (*Lambda) ProtoMessage()               {}
func (*Lambda) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Lambda) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Lambda) GetBodies() []*Value {
	if m != nil {
		return m.Bodies
	}
	return nil
}

func (m *Lambda) GetEnv() *Env {
	if m != nil {
		return m.Env
	}
	return nil
}

type LambdaRec struct {
	Self   string  `protobuf:"bytes,1,opt,name=self" json:"self,omitempty"`
	Lambda *Lambda `protobuf:"bytes,2,opt,name=lambda" json:"lambda,omitempty"`
}

func (m *LambdaRec) Reset()                    { *m = LambdaRec{} }
func (m *LambdaRec) String() string            { return proto1.CompactTextString(m) }
func (*LambdaRec) ProtoMessage()               {}
func (*LambdaRec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *LambdaRec) GetSelf() string {
	if m != nil {
		return m.Self
	}
	return ""
}

func (m *LambdaRec) GetLambda() *Lambda {
	if m != nil {
		return m.Lambda
	}
	return nil
}

type SVPair struct {
	Key   string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value *Value `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *SVPair) Reset()                    { *m = SVPair{} }
func (m *SVPair) String() string            { return proto1.CompactTextString(m) }
func (*SVPair) ProtoMessage()               {}
func (*SVPair) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *SVPair) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *SVPair) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

type Env struct {
	Pairs []*SVPair `protobuf:"bytes,1,rep,name=pairs" json:"pairs,omitempty"`
}

func (m *Env) Reset()                    { *m = Env{} }
func (m *Env) String() string            { return proto1.CompactTextString(m) }
func (*Env) ProtoMessage()               {}
func (*Env) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *Env) GetPairs() []*SVPair {
	if m != nil {
		return m.Pairs
	}
	return nil
}

type IVPair struct {
	Key   uint64 `protobuf:"varint,1,opt,name=key" json:"key,omitempty"`
	Value *Value `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *IVPair) Reset()                    { *m = IVPair{} }
func (m *IVPair) String() string            { return proto1.CompactTextString(m) }
func (*IVPair) ProtoMessage()               {}
func (*IVPair) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *IVPair) GetKey() uint64 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *IVPair) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

type Intmap struct {
	Pairs []*IVPair `protobuf:"bytes,1,rep,name=pairs" json:"pairs,omitempty"`
}

func (m *Intmap) Reset()                    { *m = Intmap{} }
func (m *Intmap) String() string            { return proto1.CompactTextString(m) }
func (*Intmap) ProtoMessage()               {}
func (*Intmap) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *Intmap) GetPairs() []*IVPair {
	if m != nil {
		return m.Pairs
	}
	return nil
}

type State struct {
	Env   *Env    `protobuf:"bytes,1,opt,name=env" json:"env,omitempty"`
	State *Intmap `protobuf:"bytes,2,opt,name=state" json:"state,omitempty"`
}

func (m *State) Reset()                    { *m = State{} }
func (m *State) String() string            { return proto1.CompactTextString(m) }
func (*State) ProtoMessage()               {}
func (*State) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *State) GetEnv() *Env {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *State) GetState() *Intmap {
	if m != nil {
		return m.State
	}
	return nil
}

func init() {
	proto1.RegisterType((*Value)(nil), "proto.Value")
	proto1.RegisterType((*Atom)(nil), "proto.Atom")
	proto1.RegisterType((*Keyword)(nil), "proto.Keyword")
	proto1.RegisterType((*String)(nil), "proto.String")
	proto1.RegisterType((*Num)(nil), "proto.Num")
	proto1.RegisterType((*Boolean)(nil), "proto.Boolean")
	proto1.RegisterType((*List)(nil), "proto.List")
	proto1.RegisterType((*Vector)(nil), "proto.Vector")
	proto1.RegisterType((*PrimFn)(nil), "proto.PrimFn")
	proto1.RegisterType((*KVPair)(nil), "proto.KVPair")
	proto1.RegisterType((*Dict)(nil), "proto.Dict")
	proto1.RegisterType((*Ref)(nil), "proto.Ref")
	proto1.RegisterType((*Lambda)(nil), "proto.Lambda")
	proto1.RegisterType((*LambdaRec)(nil), "proto.LambdaRec")
	proto1.RegisterType((*SVPair)(nil), "proto.SVPair")
	proto1.RegisterType((*Env)(nil), "proto.Env")
	proto1.RegisterType((*IVPair)(nil), "proto.IVPair")
	proto1.RegisterType((*Intmap)(nil), "proto.Intmap")
	proto1.RegisterType((*State)(nil), "proto.State")
}

func init() { proto1.RegisterFile("value.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 619 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x93, 0xd1, 0x6b, 0x1a, 0x41,
	0x10, 0xc6, 0xd5, 0xbb, 0x5b, 0xe3, 0x98, 0x04, 0xd9, 0x87, 0x76, 0x29, 0xa5, 0xd8, 0x4d, 0x4a,
	0x4b, 0xda, 0x4a, 0x69, 0xdf, 0x03, 0x0d, 0x4d, 0xd0, 0x46, 0x42, 0x38, 0xc1, 0xe7, 0x9e, 0xba,
	0x27, 0x47, 0xbc, 0x3b, 0xb9, 0x5b, 0xaf, 0xe4, 0x8f, 0xea, 0xff, 0x58, 0x66, 0x67, 0x4f, 0xb3,
	0xad, 0x01, 0x9f, 0xf4, 0xe6, 0xfb, 0xd8, 0x6f, 0x67, 0xe6, 0xb7, 0xd0, 0xad, 0xa2, 0xd5, 0x46,
	0x0d, 0xd6, 0x45, 0xae, 0x73, 0x1e, 0x98, 0x1f, 0xf9, 0xc7, 0x87, 0x60, 0x8a, 0x65, 0xfe, 0x16,
	0xfc, 0x48, 0xe7, 0xa9, 0x68, 0xf6, 0x9b, 0x1f, 0xba, 0x5f, 0xbb, 0x64, 0x1b, 0x7c, 0xd7, 0x79,
	0x3a, 0x6c, 0x84, 0x46, 0xe2, 0x17, 0xd0, 0x7e, 0x50, 0x8f, 0xbf, 0xf3, 0x62, 0x21, 0x5a, 0xc6,
	0x75, 0x6a, 0x5d, 0xb7, 0x54, 0x1d, 0x36, 0xc2, 0xda, 0xc0, 0xdf, 0x03, 0x2b, 0x75, 0x91, 0x64,
	0x4b, 0xe1, 0x19, 0xeb, 0x89, 0xb5, 0x4e, 0x4c, 0x71, 0xd8, 0x08, 0xad, 0xcc, 0xdf, 0x80, 0x97,
	0x6d, 0x52, 0xe1, 0x1b, 0x17, 0x58, 0xd7, 0xdd, 0x06, 0x53, 0x51, 0xc0, 0xd0, 0x59, 0x9e, 0xaf,
	0x54, 0x94, 0x89, 0xc0, 0x09, 0xbd, 0xa2, 0x2a, 0x86, 0x5a, 0x03, 0xf6, 0xb0, 0x4a, 0x4a, 0x2d,
	0x98, 0xd3, 0xc3, 0x38, 0x29, 0x35, 0xf6, 0x80, 0x12, 0xde, 0xab, 0x52, 0x73, 0x9d, 0x17, 0xa2,
	0xed, 0xdc, 0x6b, 0x6a, 0x8a, 0x78, 0x2f, 0x92, 0xd1, 0xb8, 0x2e, 0x92, 0xf4, 0x26, 0x13, 0x47,
	0x8e, 0xf1, 0xde, 0x14, 0xd1, 0x48, 0x32, 0x86, 0x2e, 0x92, 0xb9, 0x16, 0x1d, 0x27, 0xf4, 0x47,
	0x32, 0x37, 0xa1, 0x28, 0x61, 0x8f, 0x85, 0x8a, 0x05, 0x38, 0x3d, 0x86, 0x2a, 0xc6, 0x1e, 0x0b,
	0x15, 0x63, 0xd6, 0x2a, 0x4a, 0x67, 0x8b, 0x48, 0x74, 0x9d, 0xac, 0xb1, 0x29, 0x62, 0x16, 0xc9,
	0xfc, 0x0b, 0x74, 0xe8, 0x5f, 0xa8, 0xe6, 0xe2, 0xd8, 0x78, 0x7b, 0x8e, 0x37, 0x54, 0xf3, 0x61,
	0x23, 0xdc, 0x99, 0x30, 0x5a, 0x65, 0x95, 0x38, 0x71, 0xa2, 0xaf, 0xb3, 0x0a, 0xa3, 0x55, 0x56,
	0xf1, 0x73, 0x08, 0x4a, 0x1d, 0x69, 0x25, 0x4e, 0x8d, 0xe3, 0x78, 0xbb, 0xa6, 0x48, 0xab, 0x61,
	0x23, 0x24, 0xf1, 0xaa, 0x0d, 0x81, 0x81, 0x47, 0xbe, 0x02, 0x1f, 0x91, 0xe0, 0xfc, 0x09, 0x2d,
	0x1d, 0xc2, 0x43, 0x9e, 0x41, 0xdb, 0x82, 0xc0, 0xc5, 0x8e, 0x14, 0x72, 0xd4, 0x9f, 0xb2, 0x0f,
	0x8c, 0x10, 0xe0, 0x2f, 0xb6, 0x84, 0x90, 0xc5, 0x7e, 0xc9, 0x97, 0xe0, 0xdd, 0x6d, 0x52, 0xde,
	0x23, 0x2e, 0x50, 0xf3, 0x0c, 0x09, 0x78, 0xbe, 0xdd, 0x39, 0x9e, 0x5f, 0x43, 0x81, 0x86, 0xa3,
	0x2d, 0x02, 0xf2, 0x13, 0xf8, 0xb8, 0x6f, 0x7e, 0x0e, 0xcc, 0xdc, 0xb8, 0x14, 0xcd, 0xbe, 0xf7,
	0xa4, 0x31, 0x03, 0x7b, 0x68, 0x35, 0x39, 0x00, 0x46, 0x8b, 0x3f, 0xd0, 0x2f, 0x80, 0xd1, 0xfe,
	0xf9, 0x29, 0xb4, 0xe2, 0xcc, 0xde, 0xbc, 0x15, 0x67, 0x72, 0x0c, 0xec, 0x76, 0x7a, 0x1f, 0x25,
	0x05, 0x4e, 0xfc, 0x41, 0x3d, 0xda, 0x77, 0xe4, 0x1e, 0x83, 0x02, 0x97, 0x76, 0x96, 0xf6, 0x0d,
	0xb9, 0x0e, 0x3b, 0xe6, 0x8f, 0xe0, 0x23, 0x40, 0xfc, 0x0c, 0x82, 0x75, 0x94, 0x14, 0xf5, 0xa5,
	0x6a, 0x2e, 0x28, 0x29, 0x24, 0x0d, 0x07, 0x16, 0xaa, 0x18, 0x07, 0x86, 0x90, 0x61, 0xae, 0x6f,
	0xb0, 0x92, 0xbf, 0x80, 0x11, 0x15, 0x66, 0x5d, 0xc5, 0x92, 0x8e, 0xc1, 0x75, 0x15, 0xcb, 0x12,
	0x3b, 0x9e, 0xe5, 0x8b, 0x44, 0x95, 0xa2, 0xb5, 0xaf, 0x63, 0xd2, 0xf8, 0x6b, 0xe2, 0xc7, 0xfb,
	0x97, 0x1f, 0x43, 0x8f, 0xbc, 0x81, 0xce, 0x96, 0x3b, 0x0c, 0x29, 0xd5, 0x2a, 0xae, 0x99, 0xc0,
	0xff, 0xfc, 0xdd, 0x96, 0xec, 0xd6, 0x1e, 0xb2, 0x6b, 0xae, 0xe5, 0x25, 0xb0, 0x09, 0x4d, 0xaf,
	0xb7, 0x9b, 0x5e, 0xe7, 0xf0, 0x79, 0x5d, 0x80, 0x77, 0x9d, 0x55, 0xcf, 0x8d, 0x6b, 0xe2, 0x8c,
	0xeb, 0x12, 0xd8, 0xe8, 0xbf, 0x2c, 0xff, 0xf0, 0xac, 0xcf, 0xc0, 0x46, 0x99, 0x4e, 0xa3, 0xf5,
	0x73, 0x71, 0x23, 0x27, 0xee, 0x27, 0x04, 0xe6, 0x31, 0xd5, 0x93, 0x6c, 0xee, 0x9d, 0x24, 0x9e,
	0x45, 0xef, 0xd0, 0x9d, 0x13, 0x25, 0xd9, 0x67, 0x38, 0x63, 0xa6, 0xf8, 0xed, 0x6f, 0x00, 0x00,
	0x00, 0xff, 0xff, 0xc7, 0xdb, 0xd6, 0x25, 0xca, 0x05, 0x00, 0x00,
}
